/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_spi_master.h"

static const char* CMockString_cycles_remain_o = "cycles_remain_o";
static const char* CMockString_dev = "dev";
static const char* CMockString_dev_config = "dev_config";
static const char* CMockString_device = "device";
static const char* CMockString_dummy_o = "dummy_o";
static const char* CMockString_duty_cycle = "duty_cycle";
static const char* CMockString_eff_clk = "eff_clk";
static const char* CMockString_fapb = "fapb";
static const char* CMockString_gpio_is_used = "gpio_is_used";
static const char* CMockString_handle = "handle";
static const char* CMockString_host_id = "host_id";
static const char* CMockString_hz = "hz";
static const char* CMockString_input_delay_ns = "input_delay_ns";
static const char* CMockString_spi_bus_add_device = "spi_bus_add_device";
static const char* CMockString_spi_bus_remove_device = "spi_bus_remove_device";
static const char* CMockString_spi_device_acquire_bus = "spi_device_acquire_bus";
static const char* CMockString_spi_device_get_trans_result = "spi_device_get_trans_result";
static const char* CMockString_spi_device_polling_end = "spi_device_polling_end";
static const char* CMockString_spi_device_polling_start = "spi_device_polling_start";
static const char* CMockString_spi_device_polling_transmit = "spi_device_polling_transmit";
static const char* CMockString_spi_device_queue_trans = "spi_device_queue_trans";
static const char* CMockString_spi_device_release_bus = "spi_device_release_bus";
static const char* CMockString_spi_device_transmit = "spi_device_transmit";
static const char* CMockString_spi_get_actual_clock = "spi_get_actual_clock";
static const char* CMockString_spi_get_freq_limit = "spi_get_freq_limit";
static const char* CMockString_spi_get_timing = "spi_get_timing";
static const char* CMockString_ticks_to_wait = "ticks_to_wait";
static const char* CMockString_trans_desc = "trans_desc";
static const char* CMockString_wait = "wait";

typedef struct _CMOCK_spi_bus_add_device_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_host_device_t Expected_host_id;
  const spi_device_interface_config_t* Expected_dev_config;
  spi_device_handle_t* Expected_handle;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_host_id;
  char IgnoreArg_dev_config;
  char IgnoreArg_handle;

} CMOCK_spi_bus_add_device_CALL_INSTANCE;

typedef struct _CMOCK_spi_bus_remove_device_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_handle;

} CMOCK_spi_bus_remove_device_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_queue_trans_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t* Expected_trans_desc;
  TickType_t Expected_ticks_to_wait;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_handle;
  char IgnoreArg_trans_desc;
  char IgnoreArg_ticks_to_wait;

} CMOCK_spi_device_queue_trans_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_get_trans_result_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t** Expected_trans_desc;
  TickType_t Expected_ticks_to_wait;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_handle;
  char IgnoreArg_trans_desc;
  char IgnoreArg_ticks_to_wait;

} CMOCK_spi_device_get_trans_result_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_transmit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t* Expected_trans_desc;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_handle;
  char IgnoreArg_trans_desc;

} CMOCK_spi_device_transmit_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_polling_start_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t* Expected_trans_desc;
  TickType_t Expected_ticks_to_wait;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_handle;
  char IgnoreArg_trans_desc;
  char IgnoreArg_ticks_to_wait;

} CMOCK_spi_device_polling_start_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_polling_end_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  TickType_t Expected_ticks_to_wait;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_handle;
  char IgnoreArg_ticks_to_wait;

} CMOCK_spi_device_polling_end_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_polling_transmit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_handle;
  spi_transaction_t* Expected_trans_desc;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_handle;
  char IgnoreArg_trans_desc;

} CMOCK_spi_device_polling_transmit_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_acquire_bus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_device;
  TickType_t Expected_wait;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_device;
  char IgnoreArg_wait;

} CMOCK_spi_device_acquire_bus_CALL_INSTANCE;

typedef struct _CMOCK_spi_device_release_bus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  spi_device_handle_t Expected_dev;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_dev;

} CMOCK_spi_device_release_bus_CALL_INSTANCE;

typedef struct _CMOCK_spi_get_actual_clock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int ReturnVal;
  int Expected_fapb;
  int Expected_hz;
  int Expected_duty_cycle;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_fapb;
  char IgnoreArg_hz;
  char IgnoreArg_duty_cycle;

} CMOCK_spi_get_actual_clock_CALL_INSTANCE;

typedef struct _CMOCK_spi_get_timing_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  bool Expected_gpio_is_used;
  int Expected_input_delay_ns;
  int Expected_eff_clk;
  int* Expected_dummy_o;
  int* Expected_cycles_remain_o;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_gpio_is_used;
  char IgnoreArg_input_delay_ns;
  char IgnoreArg_eff_clk;
  char IgnoreArg_dummy_o;
  char IgnoreArg_cycles_remain_o;

} CMOCK_spi_get_timing_CALL_INSTANCE;

typedef struct _CMOCK_spi_get_freq_limit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int ReturnVal;
  bool Expected_gpio_is_used;
  int Expected_input_delay_ns;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_gpio_is_used;
  char IgnoreArg_input_delay_ns;

} CMOCK_spi_get_freq_limit_CALL_INSTANCE;

static struct mock_spi_masterInstance
{
  char spi_bus_add_device_IgnoreBool;
  esp_err_t spi_bus_add_device_FinalReturn;
  char spi_bus_add_device_CallbackBool;
  CMOCK_spi_bus_add_device_CALLBACK spi_bus_add_device_CallbackFunctionPointer;
  int spi_bus_add_device_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_bus_add_device_CallInstance;
  char spi_bus_remove_device_IgnoreBool;
  esp_err_t spi_bus_remove_device_FinalReturn;
  char spi_bus_remove_device_CallbackBool;
  CMOCK_spi_bus_remove_device_CALLBACK spi_bus_remove_device_CallbackFunctionPointer;
  int spi_bus_remove_device_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_bus_remove_device_CallInstance;
  char spi_device_queue_trans_IgnoreBool;
  esp_err_t spi_device_queue_trans_FinalReturn;
  char spi_device_queue_trans_CallbackBool;
  CMOCK_spi_device_queue_trans_CALLBACK spi_device_queue_trans_CallbackFunctionPointer;
  int spi_device_queue_trans_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_device_queue_trans_CallInstance;
  char spi_device_get_trans_result_IgnoreBool;
  esp_err_t spi_device_get_trans_result_FinalReturn;
  char spi_device_get_trans_result_CallbackBool;
  CMOCK_spi_device_get_trans_result_CALLBACK spi_device_get_trans_result_CallbackFunctionPointer;
  int spi_device_get_trans_result_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_device_get_trans_result_CallInstance;
  char spi_device_transmit_IgnoreBool;
  esp_err_t spi_device_transmit_FinalReturn;
  char spi_device_transmit_CallbackBool;
  CMOCK_spi_device_transmit_CALLBACK spi_device_transmit_CallbackFunctionPointer;
  int spi_device_transmit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_device_transmit_CallInstance;
  char spi_device_polling_start_IgnoreBool;
  esp_err_t spi_device_polling_start_FinalReturn;
  char spi_device_polling_start_CallbackBool;
  CMOCK_spi_device_polling_start_CALLBACK spi_device_polling_start_CallbackFunctionPointer;
  int spi_device_polling_start_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_device_polling_start_CallInstance;
  char spi_device_polling_end_IgnoreBool;
  esp_err_t spi_device_polling_end_FinalReturn;
  char spi_device_polling_end_CallbackBool;
  CMOCK_spi_device_polling_end_CALLBACK spi_device_polling_end_CallbackFunctionPointer;
  int spi_device_polling_end_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_device_polling_end_CallInstance;
  char spi_device_polling_transmit_IgnoreBool;
  esp_err_t spi_device_polling_transmit_FinalReturn;
  char spi_device_polling_transmit_CallbackBool;
  CMOCK_spi_device_polling_transmit_CALLBACK spi_device_polling_transmit_CallbackFunctionPointer;
  int spi_device_polling_transmit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_device_polling_transmit_CallInstance;
  char spi_device_acquire_bus_IgnoreBool;
  esp_err_t spi_device_acquire_bus_FinalReturn;
  char spi_device_acquire_bus_CallbackBool;
  CMOCK_spi_device_acquire_bus_CALLBACK spi_device_acquire_bus_CallbackFunctionPointer;
  int spi_device_acquire_bus_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_device_acquire_bus_CallInstance;
  char spi_device_release_bus_IgnoreBool;
  char spi_device_release_bus_CallbackBool;
  CMOCK_spi_device_release_bus_CALLBACK spi_device_release_bus_CallbackFunctionPointer;
  int spi_device_release_bus_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_device_release_bus_CallInstance;
  char spi_get_actual_clock_IgnoreBool;
  int spi_get_actual_clock_FinalReturn;
  char spi_get_actual_clock_CallbackBool;
  CMOCK_spi_get_actual_clock_CALLBACK spi_get_actual_clock_CallbackFunctionPointer;
  int spi_get_actual_clock_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_get_actual_clock_CallInstance;
  char spi_get_timing_IgnoreBool;
  char spi_get_timing_CallbackBool;
  CMOCK_spi_get_timing_CALLBACK spi_get_timing_CallbackFunctionPointer;
  int spi_get_timing_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_get_timing_CallInstance;
  char spi_get_freq_limit_IgnoreBool;
  int spi_get_freq_limit_FinalReturn;
  char spi_get_freq_limit_CallbackBool;
  CMOCK_spi_get_freq_limit_CALLBACK spi_get_freq_limit_CallbackFunctionPointer;
  int spi_get_freq_limit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spi_get_freq_limit_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void mock_spi_master_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.spi_bus_add_device_CallInstance;
  if (Mock.spi_bus_add_device_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_bus_add_device);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_bus_add_device_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_bus_remove_device_CallInstance;
  if (Mock.spi_bus_remove_device_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_bus_remove_device);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_bus_remove_device_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_device_queue_trans_CallInstance;
  if (Mock.spi_device_queue_trans_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_queue_trans);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_device_queue_trans_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_device_get_trans_result_CallInstance;
  if (Mock.spi_device_get_trans_result_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_get_trans_result);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_device_get_trans_result_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_device_transmit_CallInstance;
  if (Mock.spi_device_transmit_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_transmit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_device_transmit_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_device_polling_start_CallInstance;
  if (Mock.spi_device_polling_start_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_polling_start);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_device_polling_start_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_device_polling_end_CallInstance;
  if (Mock.spi_device_polling_end_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_polling_end);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_device_polling_end_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_device_polling_transmit_CallInstance;
  if (Mock.spi_device_polling_transmit_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_polling_transmit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_device_polling_transmit_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_device_acquire_bus_CallInstance;
  if (Mock.spi_device_acquire_bus_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_acquire_bus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_device_acquire_bus_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_device_release_bus_CallInstance;
  if (Mock.spi_device_release_bus_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_device_release_bus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_device_release_bus_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_get_actual_clock_CallInstance;
  if (Mock.spi_get_actual_clock_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_get_actual_clock);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_get_actual_clock_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_get_timing_CallInstance;
  if (Mock.spi_get_timing_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_get_timing);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_get_timing_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spi_get_freq_limit_CallInstance;
  if (Mock.spi_get_freq_limit_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spi_get_freq_limit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spi_get_freq_limit_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_spi_master_Init(void)
{
  mock_spi_master_Destroy();
}

void mock_spi_master_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

esp_err_t spi_bus_add_device(spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_bus_add_device);
  cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_bus_add_device_CallInstance);
  Mock.spi_bus_add_device_CallInstance = CMock_Guts_MemNext(Mock.spi_bus_add_device_CallInstance);
  if (Mock.spi_bus_add_device_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_bus_add_device_FinalReturn;
    memcpy((void*)(&Mock.spi_bus_add_device_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_bus_add_device_CallbackBool &&
      Mock.spi_bus_add_device_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_bus_add_device_CallbackFunctionPointer(host_id, dev_config, handle, Mock.spi_bus_add_device_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_host_id)
  {
    UNITY_SET_DETAILS(CMockString_spi_bus_add_device,CMockString_host_id);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_host_id), (void*)(&host_id), sizeof(spi_host_device_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_dev_config)
  {
    UNITY_SET_DETAILS(CMockString_spi_bus_add_device,CMockString_dev_config);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_dev_config), (void*)(dev_config), sizeof(const spi_device_interface_config_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_spi_bus_add_device,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_handle), (void*)(handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_bus_add_device_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_bus_add_device_CallbackFunctionPointer(host_id, dev_config, handle, Mock.spi_bus_add_device_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_bus_add_device(CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance, spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle);
void CMockExpectParameters_spi_bus_add_device(CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance, spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle)
{
  memcpy((void*)(&cmock_call_instance->Expected_host_id), (void*)(&host_id),
         sizeof(spi_host_device_t[sizeof(host_id) == sizeof(spi_host_device_t) ? 1 : -1])); /* add spi_host_device_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_host_id = 0;
  cmock_call_instance->Expected_dev_config = dev_config;
  cmock_call_instance->IgnoreArg_dev_config = 0;
  cmock_call_instance->Expected_handle = handle;
  cmock_call_instance->IgnoreArg_handle = 0;
}

void spi_bus_add_device_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_add_device_CALL_INSTANCE));
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_add_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_add_device_CallInstance, cmock_guts_index);
  Mock.spi_bus_add_device_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_bus_add_device_IgnoreBool = (char)1;
}

void spi_bus_add_device_CMockStopIgnore(void)
{
  if(Mock.spi_bus_add_device_IgnoreBool)
    Mock.spi_bus_add_device_CallInstance = CMock_Guts_MemNext(Mock.spi_bus_add_device_CallInstance);
  Mock.spi_bus_add_device_IgnoreBool = (char)0;
}

void spi_bus_add_device_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_add_device_CALL_INSTANCE));
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_add_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_add_device_CallInstance, cmock_guts_index);
  Mock.spi_bus_add_device_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_bus_add_device_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_add_device_CALL_INSTANCE));
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_add_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_add_device_CallInstance, cmock_guts_index);
  Mock.spi_bus_add_device_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_bus_add_device(cmock_call_instance, host_id, dev_config, handle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_bus_add_device_AddCallback(CMOCK_spi_bus_add_device_CALLBACK Callback)
{
  Mock.spi_bus_add_device_IgnoreBool = (char)0;
  Mock.spi_bus_add_device_CallbackBool = (char)1;
  Mock.spi_bus_add_device_CallbackFunctionPointer = Callback;
}

void spi_bus_add_device_Stub(CMOCK_spi_bus_add_device_CALLBACK Callback)
{
  Mock.spi_bus_add_device_IgnoreBool = (char)0;
  Mock.spi_bus_add_device_CallbackBool = (char)0;
  Mock.spi_bus_add_device_CallbackFunctionPointer = Callback;
}

void spi_bus_add_device_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_host_device_t host_id, const spi_device_interface_config_t* dev_config, spi_device_handle_t* handle, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_add_device_CALL_INSTANCE));
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_add_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_add_device_CallInstance, cmock_guts_index);
  Mock.spi_bus_add_device_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_bus_add_device(cmock_call_instance, host_id, dev_config, handle);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_bus_add_device_CMockIgnoreArg_host_id(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_bus_add_device_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_host_id = 1;
}

void spi_bus_add_device_CMockIgnoreArg_dev_config(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_bus_add_device_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_dev_config = 1;
}

void spi_bus_add_device_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_bus_add_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_add_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_bus_add_device_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

esp_err_t spi_bus_remove_device(spi_device_handle_t handle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_bus_remove_device);
  cmock_call_instance = (CMOCK_spi_bus_remove_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_bus_remove_device_CallInstance);
  Mock.spi_bus_remove_device_CallInstance = CMock_Guts_MemNext(Mock.spi_bus_remove_device_CallInstance);
  if (Mock.spi_bus_remove_device_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_bus_remove_device_FinalReturn;
    memcpy((void*)(&Mock.spi_bus_remove_device_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_bus_remove_device_CallbackBool &&
      Mock.spi_bus_remove_device_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_bus_remove_device_CallbackFunctionPointer(handle, Mock.spi_bus_remove_device_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_spi_bus_remove_device,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_bus_remove_device_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_bus_remove_device_CallbackFunctionPointer(handle, Mock.spi_bus_remove_device_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_bus_remove_device(CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle);
void CMockExpectParameters_spi_bus_remove_device(CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_handle = 0;
}

void spi_bus_remove_device_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_remove_device_CALL_INSTANCE));
  CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_remove_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_remove_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_remove_device_CallInstance, cmock_guts_index);
  Mock.spi_bus_remove_device_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_bus_remove_device_IgnoreBool = (char)1;
}

void spi_bus_remove_device_CMockStopIgnore(void)
{
  if(Mock.spi_bus_remove_device_IgnoreBool)
    Mock.spi_bus_remove_device_CallInstance = CMock_Guts_MemNext(Mock.spi_bus_remove_device_CallInstance);
  Mock.spi_bus_remove_device_IgnoreBool = (char)0;
}

void spi_bus_remove_device_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_remove_device_CALL_INSTANCE));
  CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_remove_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_remove_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_remove_device_CallInstance, cmock_guts_index);
  Mock.spi_bus_remove_device_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_bus_remove_device_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_remove_device_CALL_INSTANCE));
  CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_remove_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_remove_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_remove_device_CallInstance, cmock_guts_index);
  Mock.spi_bus_remove_device_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_bus_remove_device(cmock_call_instance, handle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_bus_remove_device_AddCallback(CMOCK_spi_bus_remove_device_CALLBACK Callback)
{
  Mock.spi_bus_remove_device_IgnoreBool = (char)0;
  Mock.spi_bus_remove_device_CallbackBool = (char)1;
  Mock.spi_bus_remove_device_CallbackFunctionPointer = Callback;
}

void spi_bus_remove_device_Stub(CMOCK_spi_bus_remove_device_CALLBACK Callback)
{
  Mock.spi_bus_remove_device_IgnoreBool = (char)0;
  Mock.spi_bus_remove_device_CallbackBool = (char)0;
  Mock.spi_bus_remove_device_CallbackFunctionPointer = Callback;
}

void spi_bus_remove_device_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_bus_remove_device_CALL_INSTANCE));
  CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_remove_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_bus_remove_device_CallInstance = CMock_Guts_MemChain(Mock.spi_bus_remove_device_CallInstance, cmock_guts_index);
  Mock.spi_bus_remove_device_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_bus_remove_device(cmock_call_instance, handle);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_bus_remove_device_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_bus_remove_device_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_bus_remove_device_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_bus_remove_device_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

esp_err_t spi_device_queue_trans(spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_queue_trans);
  cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_queue_trans_CallInstance);
  Mock.spi_device_queue_trans_CallInstance = CMock_Guts_MemNext(Mock.spi_device_queue_trans_CallInstance);
  if (Mock.spi_device_queue_trans_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_device_queue_trans_FinalReturn;
    memcpy((void*)(&Mock.spi_device_queue_trans_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_device_queue_trans_CallbackBool &&
      Mock.spi_device_queue_trans_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_device_queue_trans_CallbackFunctionPointer(handle, trans_desc, ticks_to_wait, Mock.spi_device_queue_trans_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_queue_trans,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_trans_desc)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_queue_trans,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_trans_desc), (void*)(trans_desc), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ticks_to_wait)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_queue_trans,CMockString_ticks_to_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_device_queue_trans_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_device_queue_trans_CallbackFunctionPointer(handle, trans_desc, ticks_to_wait, Mock.spi_device_queue_trans_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_queue_trans(CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait);
void CMockExpectParameters_spi_device_queue_trans(CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_handle = 0;
  cmock_call_instance->Expected_trans_desc = trans_desc;
  cmock_call_instance->IgnoreArg_trans_desc = 0;
  memcpy((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait),
         sizeof(TickType_t[sizeof(ticks_to_wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_ticks_to_wait = 0;
}

void spi_device_queue_trans_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_queue_trans_CALL_INSTANCE));
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_queue_trans_CallInstance = CMock_Guts_MemChain(Mock.spi_device_queue_trans_CallInstance, cmock_guts_index);
  Mock.spi_device_queue_trans_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_device_queue_trans_IgnoreBool = (char)1;
}

void spi_device_queue_trans_CMockStopIgnore(void)
{
  if(Mock.spi_device_queue_trans_IgnoreBool)
    Mock.spi_device_queue_trans_CallInstance = CMock_Guts_MemNext(Mock.spi_device_queue_trans_CallInstance);
  Mock.spi_device_queue_trans_IgnoreBool = (char)0;
}

void spi_device_queue_trans_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_queue_trans_CALL_INSTANCE));
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_queue_trans_CallInstance = CMock_Guts_MemChain(Mock.spi_device_queue_trans_CallInstance, cmock_guts_index);
  Mock.spi_device_queue_trans_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_device_queue_trans_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_queue_trans_CALL_INSTANCE));
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_queue_trans_CallInstance = CMock_Guts_MemChain(Mock.spi_device_queue_trans_CallInstance, cmock_guts_index);
  Mock.spi_device_queue_trans_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_queue_trans(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_device_queue_trans_AddCallback(CMOCK_spi_device_queue_trans_CALLBACK Callback)
{
  Mock.spi_device_queue_trans_IgnoreBool = (char)0;
  Mock.spi_device_queue_trans_CallbackBool = (char)1;
  Mock.spi_device_queue_trans_CallbackFunctionPointer = Callback;
}

void spi_device_queue_trans_Stub(CMOCK_spi_device_queue_trans_CALLBACK Callback)
{
  Mock.spi_device_queue_trans_IgnoreBool = (char)0;
  Mock.spi_device_queue_trans_CallbackBool = (char)0;
  Mock.spi_device_queue_trans_CallbackFunctionPointer = Callback;
}

void spi_device_queue_trans_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_queue_trans_CALL_INSTANCE));
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_queue_trans_CallInstance = CMock_Guts_MemChain(Mock.spi_device_queue_trans_CallInstance, cmock_guts_index);
  Mock.spi_device_queue_trans_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_queue_trans(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_device_queue_trans_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_queue_trans_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

void spi_device_queue_trans_CMockIgnoreArg_trans_desc(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_queue_trans_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_trans_desc = 1;
}

void spi_device_queue_trans_CMockIgnoreArg_ticks_to_wait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_queue_trans_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_queue_trans_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_queue_trans_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ticks_to_wait = 1;
}

esp_err_t spi_device_get_trans_result(spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_get_trans_result);
  cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_get_trans_result_CallInstance);
  Mock.spi_device_get_trans_result_CallInstance = CMock_Guts_MemNext(Mock.spi_device_get_trans_result_CallInstance);
  if (Mock.spi_device_get_trans_result_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_device_get_trans_result_FinalReturn;
    memcpy((void*)(&Mock.spi_device_get_trans_result_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_device_get_trans_result_CallbackBool &&
      Mock.spi_device_get_trans_result_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_device_get_trans_result_CallbackFunctionPointer(handle, trans_desc, ticks_to_wait, Mock.spi_device_get_trans_result_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_get_trans_result,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_trans_desc)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_get_trans_result,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_trans_desc, trans_desc, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ticks_to_wait)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_get_trans_result,CMockString_ticks_to_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_device_get_trans_result_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_device_get_trans_result_CallbackFunctionPointer(handle, trans_desc, ticks_to_wait, Mock.spi_device_get_trans_result_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_get_trans_result(CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait);
void CMockExpectParameters_spi_device_get_trans_result(CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_handle = 0;
  cmock_call_instance->Expected_trans_desc = trans_desc;
  cmock_call_instance->IgnoreArg_trans_desc = 0;
  memcpy((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait),
         sizeof(TickType_t[sizeof(ticks_to_wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_ticks_to_wait = 0;
}

void spi_device_get_trans_result_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_get_trans_result_CALL_INSTANCE));
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_get_trans_result_CallInstance = CMock_Guts_MemChain(Mock.spi_device_get_trans_result_CallInstance, cmock_guts_index);
  Mock.spi_device_get_trans_result_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_device_get_trans_result_IgnoreBool = (char)1;
}

void spi_device_get_trans_result_CMockStopIgnore(void)
{
  if(Mock.spi_device_get_trans_result_IgnoreBool)
    Mock.spi_device_get_trans_result_CallInstance = CMock_Guts_MemNext(Mock.spi_device_get_trans_result_CallInstance);
  Mock.spi_device_get_trans_result_IgnoreBool = (char)0;
}

void spi_device_get_trans_result_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_get_trans_result_CALL_INSTANCE));
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_get_trans_result_CallInstance = CMock_Guts_MemChain(Mock.spi_device_get_trans_result_CallInstance, cmock_guts_index);
  Mock.spi_device_get_trans_result_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_device_get_trans_result_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_get_trans_result_CALL_INSTANCE));
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_get_trans_result_CallInstance = CMock_Guts_MemChain(Mock.spi_device_get_trans_result_CallInstance, cmock_guts_index);
  Mock.spi_device_get_trans_result_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_get_trans_result(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_device_get_trans_result_AddCallback(CMOCK_spi_device_get_trans_result_CALLBACK Callback)
{
  Mock.spi_device_get_trans_result_IgnoreBool = (char)0;
  Mock.spi_device_get_trans_result_CallbackBool = (char)1;
  Mock.spi_device_get_trans_result_CallbackFunctionPointer = Callback;
}

void spi_device_get_trans_result_Stub(CMOCK_spi_device_get_trans_result_CALLBACK Callback)
{
  Mock.spi_device_get_trans_result_IgnoreBool = (char)0;
  Mock.spi_device_get_trans_result_CallbackBool = (char)0;
  Mock.spi_device_get_trans_result_CallbackFunctionPointer = Callback;
}

void spi_device_get_trans_result_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t** trans_desc, TickType_t ticks_to_wait, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_get_trans_result_CALL_INSTANCE));
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_get_trans_result_CallInstance = CMock_Guts_MemChain(Mock.spi_device_get_trans_result_CallInstance, cmock_guts_index);
  Mock.spi_device_get_trans_result_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_get_trans_result(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_device_get_trans_result_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_get_trans_result_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

void spi_device_get_trans_result_CMockIgnoreArg_trans_desc(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_get_trans_result_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_trans_desc = 1;
}

void spi_device_get_trans_result_CMockIgnoreArg_ticks_to_wait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_get_trans_result_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_get_trans_result_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_get_trans_result_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ticks_to_wait = 1;
}

esp_err_t spi_device_transmit(spi_device_handle_t handle, spi_transaction_t* trans_desc)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_transmit);
  cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_transmit_CallInstance);
  Mock.spi_device_transmit_CallInstance = CMock_Guts_MemNext(Mock.spi_device_transmit_CallInstance);
  if (Mock.spi_device_transmit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_device_transmit_FinalReturn;
    memcpy((void*)(&Mock.spi_device_transmit_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_device_transmit_CallbackBool &&
      Mock.spi_device_transmit_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_device_transmit_CallbackFunctionPointer(handle, trans_desc, Mock.spi_device_transmit_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_transmit,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_trans_desc)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_transmit,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_trans_desc), (void*)(trans_desc), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_device_transmit_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_device_transmit_CallbackFunctionPointer(handle, trans_desc, Mock.spi_device_transmit_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_transmit(CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc);
void CMockExpectParameters_spi_device_transmit(CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_handle = 0;
  cmock_call_instance->Expected_trans_desc = trans_desc;
  cmock_call_instance->IgnoreArg_trans_desc = 0;
}

void spi_device_transmit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_transmit_CALL_INSTANCE));
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_transmit_CallInstance, cmock_guts_index);
  Mock.spi_device_transmit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_device_transmit_IgnoreBool = (char)1;
}

void spi_device_transmit_CMockStopIgnore(void)
{
  if(Mock.spi_device_transmit_IgnoreBool)
    Mock.spi_device_transmit_CallInstance = CMock_Guts_MemNext(Mock.spi_device_transmit_CallInstance);
  Mock.spi_device_transmit_IgnoreBool = (char)0;
}

void spi_device_transmit_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_transmit_CALL_INSTANCE));
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_transmit_CallInstance, cmock_guts_index);
  Mock.spi_device_transmit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_device_transmit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_transmit_CALL_INSTANCE));
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_transmit_CallInstance, cmock_guts_index);
  Mock.spi_device_transmit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_transmit(cmock_call_instance, handle, trans_desc);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_device_transmit_AddCallback(CMOCK_spi_device_transmit_CALLBACK Callback)
{
  Mock.spi_device_transmit_IgnoreBool = (char)0;
  Mock.spi_device_transmit_CallbackBool = (char)1;
  Mock.spi_device_transmit_CallbackFunctionPointer = Callback;
}

void spi_device_transmit_Stub(CMOCK_spi_device_transmit_CALLBACK Callback)
{
  Mock.spi_device_transmit_IgnoreBool = (char)0;
  Mock.spi_device_transmit_CallbackBool = (char)0;
  Mock.spi_device_transmit_CallbackFunctionPointer = Callback;
}

void spi_device_transmit_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_transmit_CALL_INSTANCE));
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_transmit_CallInstance, cmock_guts_index);
  Mock.spi_device_transmit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_transmit(cmock_call_instance, handle, trans_desc);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_device_transmit_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_transmit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

void spi_device_transmit_CMockIgnoreArg_trans_desc(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_transmit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_trans_desc = 1;
}

esp_err_t spi_device_polling_start(spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_polling_start);
  cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_polling_start_CallInstance);
  Mock.spi_device_polling_start_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_start_CallInstance);
  if (Mock.spi_device_polling_start_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_device_polling_start_FinalReturn;
    memcpy((void*)(&Mock.spi_device_polling_start_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_device_polling_start_CallbackBool &&
      Mock.spi_device_polling_start_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_device_polling_start_CallbackFunctionPointer(handle, trans_desc, ticks_to_wait, Mock.spi_device_polling_start_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_start,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_trans_desc)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_start,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_trans_desc), (void*)(trans_desc), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ticks_to_wait)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_start,CMockString_ticks_to_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_device_polling_start_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_device_polling_start_CallbackFunctionPointer(handle, trans_desc, ticks_to_wait, Mock.spi_device_polling_start_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_polling_start(CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait);
void CMockExpectParameters_spi_device_polling_start(CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_handle = 0;
  cmock_call_instance->Expected_trans_desc = trans_desc;
  cmock_call_instance->IgnoreArg_trans_desc = 0;
  memcpy((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait),
         sizeof(TickType_t[sizeof(ticks_to_wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_ticks_to_wait = 0;
}

void spi_device_polling_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_start_CALL_INSTANCE));
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_start_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_start_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_device_polling_start_IgnoreBool = (char)1;
}

void spi_device_polling_start_CMockStopIgnore(void)
{
  if(Mock.spi_device_polling_start_IgnoreBool)
    Mock.spi_device_polling_start_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_start_CallInstance);
  Mock.spi_device_polling_start_IgnoreBool = (char)0;
}

void spi_device_polling_start_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_start_CALL_INSTANCE));
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_start_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_start_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_device_polling_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_start_CALL_INSTANCE));
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_start_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_start_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_polling_start(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_device_polling_start_AddCallback(CMOCK_spi_device_polling_start_CALLBACK Callback)
{
  Mock.spi_device_polling_start_IgnoreBool = (char)0;
  Mock.spi_device_polling_start_CallbackBool = (char)1;
  Mock.spi_device_polling_start_CallbackFunctionPointer = Callback;
}

void spi_device_polling_start_Stub(CMOCK_spi_device_polling_start_CALLBACK Callback)
{
  Mock.spi_device_polling_start_IgnoreBool = (char)0;
  Mock.spi_device_polling_start_CallbackBool = (char)0;
  Mock.spi_device_polling_start_CallbackFunctionPointer = Callback;
}

void spi_device_polling_start_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, TickType_t ticks_to_wait, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_start_CALL_INSTANCE));
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_start_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_start_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_polling_start(cmock_call_instance, handle, trans_desc, ticks_to_wait);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_device_polling_start_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_polling_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

void spi_device_polling_start_CMockIgnoreArg_trans_desc(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_polling_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_trans_desc = 1;
}

void spi_device_polling_start_CMockIgnoreArg_ticks_to_wait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_polling_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_polling_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ticks_to_wait = 1;
}

esp_err_t spi_device_polling_end(spi_device_handle_t handle, TickType_t ticks_to_wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_polling_end);
  cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_polling_end_CallInstance);
  Mock.spi_device_polling_end_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_end_CallInstance);
  if (Mock.spi_device_polling_end_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_device_polling_end_FinalReturn;
    memcpy((void*)(&Mock.spi_device_polling_end_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_device_polling_end_CallbackBool &&
      Mock.spi_device_polling_end_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_device_polling_end_CallbackFunctionPointer(handle, ticks_to_wait, Mock.spi_device_polling_end_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_end,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ticks_to_wait)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_end,CMockString_ticks_to_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_device_polling_end_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_device_polling_end_CallbackFunctionPointer(handle, ticks_to_wait, Mock.spi_device_polling_end_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_polling_end(CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, TickType_t ticks_to_wait);
void CMockExpectParameters_spi_device_polling_end(CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, TickType_t ticks_to_wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_handle = 0;
  memcpy((void*)(&cmock_call_instance->Expected_ticks_to_wait), (void*)(&ticks_to_wait),
         sizeof(TickType_t[sizeof(ticks_to_wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_ticks_to_wait = 0;
}

void spi_device_polling_end_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_end_CALL_INSTANCE));
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_end_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_end_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_end_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_device_polling_end_IgnoreBool = (char)1;
}

void spi_device_polling_end_CMockStopIgnore(void)
{
  if(Mock.spi_device_polling_end_IgnoreBool)
    Mock.spi_device_polling_end_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_end_CallInstance);
  Mock.spi_device_polling_end_IgnoreBool = (char)0;
}

void spi_device_polling_end_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_end_CALL_INSTANCE));
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_end_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_end_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_end_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_device_polling_end_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, TickType_t ticks_to_wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_end_CALL_INSTANCE));
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_end_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_end_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_end_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_polling_end(cmock_call_instance, handle, ticks_to_wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_device_polling_end_AddCallback(CMOCK_spi_device_polling_end_CALLBACK Callback)
{
  Mock.spi_device_polling_end_IgnoreBool = (char)0;
  Mock.spi_device_polling_end_CallbackBool = (char)1;
  Mock.spi_device_polling_end_CallbackFunctionPointer = Callback;
}

void spi_device_polling_end_Stub(CMOCK_spi_device_polling_end_CALLBACK Callback)
{
  Mock.spi_device_polling_end_IgnoreBool = (char)0;
  Mock.spi_device_polling_end_CallbackBool = (char)0;
  Mock.spi_device_polling_end_CallbackFunctionPointer = Callback;
}

void spi_device_polling_end_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, TickType_t ticks_to_wait, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_end_CALL_INSTANCE));
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_end_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_end_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_end_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_polling_end(cmock_call_instance, handle, ticks_to_wait);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_device_polling_end_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_polling_end_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

void spi_device_polling_end_CMockIgnoreArg_ticks_to_wait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_polling_end_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_end_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_polling_end_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ticks_to_wait = 1;
}

esp_err_t spi_device_polling_transmit(spi_device_handle_t handle, spi_transaction_t* trans_desc)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_polling_transmit);
  cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_polling_transmit_CallInstance);
  Mock.spi_device_polling_transmit_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_transmit_CallInstance);
  if (Mock.spi_device_polling_transmit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_device_polling_transmit_FinalReturn;
    memcpy((void*)(&Mock.spi_device_polling_transmit_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_device_polling_transmit_CallbackBool &&
      Mock.spi_device_polling_transmit_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_device_polling_transmit_CallbackFunctionPointer(handle, trans_desc, Mock.spi_device_polling_transmit_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_transmit,CMockString_handle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_trans_desc)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_polling_transmit,CMockString_trans_desc);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_trans_desc), (void*)(trans_desc), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_device_polling_transmit_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_device_polling_transmit_CallbackFunctionPointer(handle, trans_desc, Mock.spi_device_polling_transmit_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_polling_transmit(CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc);
void CMockExpectParameters_spi_device_polling_transmit(CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t handle, spi_transaction_t* trans_desc)
{
  memcpy((void*)(&cmock_call_instance->Expected_handle), (void*)(&handle),
         sizeof(spi_device_handle_t[sizeof(handle) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_handle = 0;
  cmock_call_instance->Expected_trans_desc = trans_desc;
  cmock_call_instance->IgnoreArg_trans_desc = 0;
}

void spi_device_polling_transmit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_transmit_CALL_INSTANCE));
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_transmit_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_transmit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_device_polling_transmit_IgnoreBool = (char)1;
}

void spi_device_polling_transmit_CMockStopIgnore(void)
{
  if(Mock.spi_device_polling_transmit_IgnoreBool)
    Mock.spi_device_polling_transmit_CallInstance = CMock_Guts_MemNext(Mock.spi_device_polling_transmit_CallInstance);
  Mock.spi_device_polling_transmit_IgnoreBool = (char)0;
}

void spi_device_polling_transmit_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_transmit_CALL_INSTANCE));
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_transmit_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_transmit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_device_polling_transmit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_transmit_CALL_INSTANCE));
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_transmit_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_transmit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_polling_transmit(cmock_call_instance, handle, trans_desc);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_device_polling_transmit_AddCallback(CMOCK_spi_device_polling_transmit_CALLBACK Callback)
{
  Mock.spi_device_polling_transmit_IgnoreBool = (char)0;
  Mock.spi_device_polling_transmit_CallbackBool = (char)1;
  Mock.spi_device_polling_transmit_CallbackFunctionPointer = Callback;
}

void spi_device_polling_transmit_Stub(CMOCK_spi_device_polling_transmit_CALLBACK Callback)
{
  Mock.spi_device_polling_transmit_IgnoreBool = (char)0;
  Mock.spi_device_polling_transmit_CallbackBool = (char)0;
  Mock.spi_device_polling_transmit_CallbackFunctionPointer = Callback;
}

void spi_device_polling_transmit_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t handle, spi_transaction_t* trans_desc, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_polling_transmit_CALL_INSTANCE));
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_polling_transmit_CallInstance = CMock_Guts_MemChain(Mock.spi_device_polling_transmit_CallInstance, cmock_guts_index);
  Mock.spi_device_polling_transmit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_polling_transmit(cmock_call_instance, handle, trans_desc);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_device_polling_transmit_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_polling_transmit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

void spi_device_polling_transmit_CMockIgnoreArg_trans_desc(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_polling_transmit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_polling_transmit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_polling_transmit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_trans_desc = 1;
}

esp_err_t spi_device_acquire_bus(spi_device_handle_t device, TickType_t wait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_acquire_bus);
  cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_acquire_bus_CallInstance);
  Mock.spi_device_acquire_bus_CallInstance = CMock_Guts_MemNext(Mock.spi_device_acquire_bus_CallInstance);
  if (Mock.spi_device_acquire_bus_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_device_acquire_bus_FinalReturn;
    memcpy((void*)(&Mock.spi_device_acquire_bus_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_device_acquire_bus_CallbackBool &&
      Mock.spi_device_acquire_bus_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.spi_device_acquire_bus_CallbackFunctionPointer(device, wait, Mock.spi_device_acquire_bus_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_device)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_acquire_bus,CMockString_device);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_device), (void*)(&device), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_wait)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_acquire_bus,CMockString_wait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wait), (void*)(&wait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_device_acquire_bus_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_device_acquire_bus_CallbackFunctionPointer(device, wait, Mock.spi_device_acquire_bus_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_device_acquire_bus(CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t device, TickType_t wait);
void CMockExpectParameters_spi_device_acquire_bus(CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t device, TickType_t wait)
{
  memcpy((void*)(&cmock_call_instance->Expected_device), (void*)(&device),
         sizeof(spi_device_handle_t[sizeof(device) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_device = 0;
  memcpy((void*)(&cmock_call_instance->Expected_wait), (void*)(&wait),
         sizeof(TickType_t[sizeof(wait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_wait = 0;
}

void spi_device_acquire_bus_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_acquire_bus_CALL_INSTANCE));
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_acquire_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_acquire_bus_CallInstance, cmock_guts_index);
  Mock.spi_device_acquire_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_device_acquire_bus_IgnoreBool = (char)1;
}

void spi_device_acquire_bus_CMockStopIgnore(void)
{
  if(Mock.spi_device_acquire_bus_IgnoreBool)
    Mock.spi_device_acquire_bus_CallInstance = CMock_Guts_MemNext(Mock.spi_device_acquire_bus_CallInstance);
  Mock.spi_device_acquire_bus_IgnoreBool = (char)0;
}

void spi_device_acquire_bus_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_acquire_bus_CALL_INSTANCE));
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_acquire_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_acquire_bus_CallInstance, cmock_guts_index);
  Mock.spi_device_acquire_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_device_acquire_bus_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t device, TickType_t wait, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_acquire_bus_CALL_INSTANCE));
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_acquire_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_acquire_bus_CallInstance, cmock_guts_index);
  Mock.spi_device_acquire_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_acquire_bus(cmock_call_instance, device, wait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void spi_device_acquire_bus_AddCallback(CMOCK_spi_device_acquire_bus_CALLBACK Callback)
{
  Mock.spi_device_acquire_bus_IgnoreBool = (char)0;
  Mock.spi_device_acquire_bus_CallbackBool = (char)1;
  Mock.spi_device_acquire_bus_CallbackFunctionPointer = Callback;
}

void spi_device_acquire_bus_Stub(CMOCK_spi_device_acquire_bus_CALLBACK Callback)
{
  Mock.spi_device_acquire_bus_IgnoreBool = (char)0;
  Mock.spi_device_acquire_bus_CallbackBool = (char)0;
  Mock.spi_device_acquire_bus_CallbackFunctionPointer = Callback;
}

void spi_device_acquire_bus_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t device, TickType_t wait, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_acquire_bus_CALL_INSTANCE));
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_acquire_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_acquire_bus_CallInstance, cmock_guts_index);
  Mock.spi_device_acquire_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_acquire_bus(cmock_call_instance, device, wait);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_device_acquire_bus_CMockIgnoreArg_device(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_acquire_bus_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_device = 1;
}

void spi_device_acquire_bus_CMockIgnoreArg_wait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_acquire_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_acquire_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_acquire_bus_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_wait = 1;
}

void spi_device_release_bus(spi_device_handle_t dev)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_device_release_bus);
  cmock_call_instance = (CMOCK_spi_device_release_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_device_release_bus_CallInstance);
  Mock.spi_device_release_bus_CallInstance = CMock_Guts_MemNext(Mock.spi_device_release_bus_CallInstance);
  if (Mock.spi_device_release_bus_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.spi_device_release_bus_CallbackBool &&
      Mock.spi_device_release_bus_CallbackFunctionPointer != NULL)
  {
    Mock.spi_device_release_bus_CallbackFunctionPointer(dev, Mock.spi_device_release_bus_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_dev)
  {
    UNITY_SET_DETAILS(CMockString_spi_device_release_bus,CMockString_dev);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dev), (void*)(&dev), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_device_release_bus_CallbackFunctionPointer != NULL)
  {
    Mock.spi_device_release_bus_CallbackFunctionPointer(dev, Mock.spi_device_release_bus_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_spi_device_release_bus(CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t dev);
void CMockExpectParameters_spi_device_release_bus(CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t dev)
{
  memcpy((void*)(&cmock_call_instance->Expected_dev), (void*)(&dev),
         sizeof(spi_device_handle_t[sizeof(dev) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_dev = 0;
}

void spi_device_release_bus_CMockIgnore(void)
{
  Mock.spi_device_release_bus_IgnoreBool = (char)1;
}

void spi_device_release_bus_CMockStopIgnore(void)
{
  Mock.spi_device_release_bus_IgnoreBool = (char)0;
}

void spi_device_release_bus_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_release_bus_CALL_INSTANCE));
  CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_release_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_release_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_release_bus_CallInstance, cmock_guts_index);
  Mock.spi_device_release_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_device_release_bus_CMockExpect(UNITY_LINE_TYPE cmock_line, spi_device_handle_t dev)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_release_bus_CALL_INSTANCE));
  CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_release_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_release_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_release_bus_CallInstance, cmock_guts_index);
  Mock.spi_device_release_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_release_bus(cmock_call_instance, dev);
}

void spi_device_release_bus_AddCallback(CMOCK_spi_device_release_bus_CALLBACK Callback)
{
  Mock.spi_device_release_bus_IgnoreBool = (char)0;
  Mock.spi_device_release_bus_CallbackBool = (char)1;
  Mock.spi_device_release_bus_CallbackFunctionPointer = Callback;
}

void spi_device_release_bus_Stub(CMOCK_spi_device_release_bus_CALLBACK Callback)
{
  Mock.spi_device_release_bus_IgnoreBool = (char)0;
  Mock.spi_device_release_bus_CallbackBool = (char)0;
  Mock.spi_device_release_bus_CallbackFunctionPointer = Callback;
}

void spi_device_release_bus_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t dev, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_device_release_bus_CALL_INSTANCE));
  CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_release_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_device_release_bus_CallInstance = CMock_Guts_MemChain(Mock.spi_device_release_bus_CallInstance, cmock_guts_index);
  Mock.spi_device_release_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_device_release_bus(cmock_call_instance, dev);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_device_release_bus_CMockIgnoreArg_dev(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_device_release_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_device_release_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_device_release_bus_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_dev = 1;
}

int spi_get_actual_clock(int fapb, int hz, int duty_cycle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_get_actual_clock);
  cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_get_actual_clock_CallInstance);
  Mock.spi_get_actual_clock_CallInstance = CMock_Guts_MemNext(Mock.spi_get_actual_clock_CallInstance);
  if (Mock.spi_get_actual_clock_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_get_actual_clock_FinalReturn;
    Mock.spi_get_actual_clock_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_get_actual_clock_CallbackBool &&
      Mock.spi_get_actual_clock_CallbackFunctionPointer != NULL)
  {
    int cmock_cb_ret = Mock.spi_get_actual_clock_CallbackFunctionPointer(fapb, hz, duty_cycle, Mock.spi_get_actual_clock_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_fapb)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_actual_clock,CMockString_fapb);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_fapb, fapb, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_hz)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_actual_clock,CMockString_hz);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hz, hz, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_duty_cycle)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_actual_clock,CMockString_duty_cycle);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_duty_cycle, duty_cycle, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_get_actual_clock_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_get_actual_clock_CallbackFunctionPointer(fapb, hz, duty_cycle, Mock.spi_get_actual_clock_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_get_actual_clock(CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance, int fapb, int hz, int duty_cycle);
void CMockExpectParameters_spi_get_actual_clock(CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance, int fapb, int hz, int duty_cycle)
{
  cmock_call_instance->Expected_fapb = fapb;
  cmock_call_instance->IgnoreArg_fapb = 0;
  cmock_call_instance->Expected_hz = hz;
  cmock_call_instance->IgnoreArg_hz = 0;
  cmock_call_instance->Expected_duty_cycle = duty_cycle;
  cmock_call_instance->IgnoreArg_duty_cycle = 0;
}

void spi_get_actual_clock_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_actual_clock_CALL_INSTANCE));
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_actual_clock_CallInstance = CMock_Guts_MemChain(Mock.spi_get_actual_clock_CallInstance, cmock_guts_index);
  Mock.spi_get_actual_clock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_get_actual_clock_IgnoreBool = (char)1;
}

void spi_get_actual_clock_CMockStopIgnore(void)
{
  if(Mock.spi_get_actual_clock_IgnoreBool)
    Mock.spi_get_actual_clock_CallInstance = CMock_Guts_MemNext(Mock.spi_get_actual_clock_CallInstance);
  Mock.spi_get_actual_clock_IgnoreBool = (char)0;
}

void spi_get_actual_clock_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_actual_clock_CALL_INSTANCE));
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_actual_clock_CallInstance = CMock_Guts_MemChain(Mock.spi_get_actual_clock_CallInstance, cmock_guts_index);
  Mock.spi_get_actual_clock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_get_actual_clock_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int fapb, int hz, int duty_cycle, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_actual_clock_CALL_INSTANCE));
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_actual_clock_CallInstance = CMock_Guts_MemChain(Mock.spi_get_actual_clock_CallInstance, cmock_guts_index);
  Mock.spi_get_actual_clock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_get_actual_clock(cmock_call_instance, fapb, hz, duty_cycle);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void spi_get_actual_clock_AddCallback(CMOCK_spi_get_actual_clock_CALLBACK Callback)
{
  Mock.spi_get_actual_clock_IgnoreBool = (char)0;
  Mock.spi_get_actual_clock_CallbackBool = (char)1;
  Mock.spi_get_actual_clock_CallbackFunctionPointer = Callback;
}

void spi_get_actual_clock_Stub(CMOCK_spi_get_actual_clock_CALLBACK Callback)
{
  Mock.spi_get_actual_clock_IgnoreBool = (char)0;
  Mock.spi_get_actual_clock_CallbackBool = (char)0;
  Mock.spi_get_actual_clock_CallbackFunctionPointer = Callback;
}

void spi_get_actual_clock_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, int fapb, int hz, int duty_cycle, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_actual_clock_CALL_INSTANCE));
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_actual_clock_CallInstance = CMock_Guts_MemChain(Mock.spi_get_actual_clock_CallInstance, cmock_guts_index);
  Mock.spi_get_actual_clock_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_get_actual_clock(cmock_call_instance, fapb, hz, duty_cycle);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_get_actual_clock_CMockIgnoreArg_fapb(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_actual_clock_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fapb = 1;
}

void spi_get_actual_clock_CMockIgnoreArg_hz(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_actual_clock_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_hz = 1;
}

void spi_get_actual_clock_CMockIgnoreArg_duty_cycle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_actual_clock_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_actual_clock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_actual_clock_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_duty_cycle = 1;
}

void spi_get_timing(bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_get_timing);
  cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_get_timing_CallInstance);
  Mock.spi_get_timing_CallInstance = CMock_Guts_MemNext(Mock.spi_get_timing_CallInstance);
  if (Mock.spi_get_timing_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.spi_get_timing_CallbackBool &&
      Mock.spi_get_timing_CallbackFunctionPointer != NULL)
  {
    Mock.spi_get_timing_CallbackFunctionPointer(gpio_is_used, input_delay_ns, eff_clk, dummy_o, cycles_remain_o, Mock.spi_get_timing_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_gpio_is_used)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_gpio_is_used);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_gpio_is_used, gpio_is_used, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_input_delay_ns)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_input_delay_ns);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_input_delay_ns, input_delay_ns, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_eff_clk)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_eff_clk);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_eff_clk, eff_clk, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_dummy_o)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_dummy_o);
    if (cmock_call_instance->Expected_dummy_o == NULL)
      { UNITY_TEST_ASSERT_NULL(dummy_o, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_dummy_o, dummy_o, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_cycles_remain_o)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_timing,CMockString_cycles_remain_o);
    if (cmock_call_instance->Expected_cycles_remain_o == NULL)
      { UNITY_TEST_ASSERT_NULL(cycles_remain_o, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_cycles_remain_o, cycles_remain_o, 1, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.spi_get_timing_CallbackFunctionPointer != NULL)
  {
    Mock.spi_get_timing_CallbackFunctionPointer(gpio_is_used, input_delay_ns, eff_clk, dummy_o, cycles_remain_o, Mock.spi_get_timing_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_spi_get_timing(CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance, bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o);
void CMockExpectParameters_spi_get_timing(CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance, bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o)
{
  cmock_call_instance->Expected_gpio_is_used = gpio_is_used;
  cmock_call_instance->IgnoreArg_gpio_is_used = 0;
  cmock_call_instance->Expected_input_delay_ns = input_delay_ns;
  cmock_call_instance->IgnoreArg_input_delay_ns = 0;
  cmock_call_instance->Expected_eff_clk = eff_clk;
  cmock_call_instance->IgnoreArg_eff_clk = 0;
  cmock_call_instance->Expected_dummy_o = dummy_o;
  cmock_call_instance->IgnoreArg_dummy_o = 0;
  cmock_call_instance->Expected_cycles_remain_o = cycles_remain_o;
  cmock_call_instance->IgnoreArg_cycles_remain_o = 0;
}

void spi_get_timing_CMockIgnore(void)
{
  Mock.spi_get_timing_IgnoreBool = (char)1;
}

void spi_get_timing_CMockStopIgnore(void)
{
  Mock.spi_get_timing_IgnoreBool = (char)0;
}

void spi_get_timing_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_timing_CALL_INSTANCE));
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_timing_CallInstance = CMock_Guts_MemChain(Mock.spi_get_timing_CallInstance, cmock_guts_index);
  Mock.spi_get_timing_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_get_timing_CMockExpect(UNITY_LINE_TYPE cmock_line, bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_timing_CALL_INSTANCE));
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_timing_CallInstance = CMock_Guts_MemChain(Mock.spi_get_timing_CallInstance, cmock_guts_index);
  Mock.spi_get_timing_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_get_timing(cmock_call_instance, gpio_is_used, input_delay_ns, eff_clk, dummy_o, cycles_remain_o);
}

void spi_get_timing_AddCallback(CMOCK_spi_get_timing_CALLBACK Callback)
{
  Mock.spi_get_timing_IgnoreBool = (char)0;
  Mock.spi_get_timing_CallbackBool = (char)1;
  Mock.spi_get_timing_CallbackFunctionPointer = Callback;
}

void spi_get_timing_Stub(CMOCK_spi_get_timing_CALLBACK Callback)
{
  Mock.spi_get_timing_IgnoreBool = (char)0;
  Mock.spi_get_timing_CallbackBool = (char)0;
  Mock.spi_get_timing_CallbackFunctionPointer = Callback;
}

void spi_get_timing_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, bool gpio_is_used, int input_delay_ns, int eff_clk, int* dummy_o, int* cycles_remain_o, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_timing_CALL_INSTANCE));
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_timing_CallInstance = CMock_Guts_MemChain(Mock.spi_get_timing_CallInstance, cmock_guts_index);
  Mock.spi_get_timing_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_get_timing(cmock_call_instance, gpio_is_used, input_delay_ns, eff_clk, dummy_o, cycles_remain_o);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_get_timing_CMockIgnoreArg_gpio_is_used(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_timing_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_is_used = 1;
}

void spi_get_timing_CMockIgnoreArg_input_delay_ns(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_timing_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_input_delay_ns = 1;
}

void spi_get_timing_CMockIgnoreArg_eff_clk(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_timing_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_eff_clk = 1;
}

void spi_get_timing_CMockIgnoreArg_dummy_o(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_timing_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_dummy_o = 1;
}

void spi_get_timing_CMockIgnoreArg_cycles_remain_o(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_timing_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_timing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_timing_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_cycles_remain_o = 1;
}

int spi_get_freq_limit(bool gpio_is_used, int input_delay_ns)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spi_get_freq_limit);
  cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spi_get_freq_limit_CallInstance);
  Mock.spi_get_freq_limit_CallInstance = CMock_Guts_MemNext(Mock.spi_get_freq_limit_CallInstance);
  if (Mock.spi_get_freq_limit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spi_get_freq_limit_FinalReturn;
    Mock.spi_get_freq_limit_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spi_get_freq_limit_CallbackBool &&
      Mock.spi_get_freq_limit_CallbackFunctionPointer != NULL)
  {
    int cmock_cb_ret = Mock.spi_get_freq_limit_CallbackFunctionPointer(gpio_is_used, input_delay_ns, Mock.spi_get_freq_limit_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_gpio_is_used)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_freq_limit,CMockString_gpio_is_used);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_gpio_is_used, gpio_is_used, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_input_delay_ns)
  {
    UNITY_SET_DETAILS(CMockString_spi_get_freq_limit,CMockString_input_delay_ns);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_input_delay_ns, input_delay_ns, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.spi_get_freq_limit_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spi_get_freq_limit_CallbackFunctionPointer(gpio_is_used, input_delay_ns, Mock.spi_get_freq_limit_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spi_get_freq_limit(CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance, bool gpio_is_used, int input_delay_ns);
void CMockExpectParameters_spi_get_freq_limit(CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance, bool gpio_is_used, int input_delay_ns)
{
  cmock_call_instance->Expected_gpio_is_used = gpio_is_used;
  cmock_call_instance->IgnoreArg_gpio_is_used = 0;
  cmock_call_instance->Expected_input_delay_ns = input_delay_ns;
  cmock_call_instance->IgnoreArg_input_delay_ns = 0;
}

void spi_get_freq_limit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_freq_limit_CALL_INSTANCE));
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_freq_limit_CallInstance = CMock_Guts_MemChain(Mock.spi_get_freq_limit_CallInstance, cmock_guts_index);
  Mock.spi_get_freq_limit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spi_get_freq_limit_IgnoreBool = (char)1;
}

void spi_get_freq_limit_CMockStopIgnore(void)
{
  if(Mock.spi_get_freq_limit_IgnoreBool)
    Mock.spi_get_freq_limit_CallInstance = CMock_Guts_MemNext(Mock.spi_get_freq_limit_CallInstance);
  Mock.spi_get_freq_limit_IgnoreBool = (char)0;
}

void spi_get_freq_limit_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_freq_limit_CALL_INSTANCE));
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_freq_limit_CallInstance = CMock_Guts_MemChain(Mock.spi_get_freq_limit_CallInstance, cmock_guts_index);
  Mock.spi_get_freq_limit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void spi_get_freq_limit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, bool gpio_is_used, int input_delay_ns, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_freq_limit_CALL_INSTANCE));
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_freq_limit_CallInstance = CMock_Guts_MemChain(Mock.spi_get_freq_limit_CallInstance, cmock_guts_index);
  Mock.spi_get_freq_limit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_get_freq_limit(cmock_call_instance, gpio_is_used, input_delay_ns);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void spi_get_freq_limit_AddCallback(CMOCK_spi_get_freq_limit_CALLBACK Callback)
{
  Mock.spi_get_freq_limit_IgnoreBool = (char)0;
  Mock.spi_get_freq_limit_CallbackBool = (char)1;
  Mock.spi_get_freq_limit_CallbackFunctionPointer = Callback;
}

void spi_get_freq_limit_Stub(CMOCK_spi_get_freq_limit_CALLBACK Callback)
{
  Mock.spi_get_freq_limit_IgnoreBool = (char)0;
  Mock.spi_get_freq_limit_CallbackBool = (char)0;
  Mock.spi_get_freq_limit_CallbackFunctionPointer = Callback;
}

void spi_get_freq_limit_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, bool gpio_is_used, int input_delay_ns, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spi_get_freq_limit_CALL_INSTANCE));
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spi_get_freq_limit_CallInstance = CMock_Guts_MemChain(Mock.spi_get_freq_limit_CallInstance, cmock_guts_index);
  Mock.spi_get_freq_limit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_spi_get_freq_limit(cmock_call_instance, gpio_is_used, input_delay_ns);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void spi_get_freq_limit_CMockIgnoreArg_gpio_is_used(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_freq_limit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_is_used = 1;
}

void spi_get_freq_limit_CMockIgnoreArg_input_delay_ns(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_spi_get_freq_limit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spi_get_freq_limit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spi_get_freq_limit_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_input_delay_ns = 1;
}

