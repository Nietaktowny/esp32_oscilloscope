/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_lcd_controller.h"

static const char* CMockString_cmd = "cmd";
static const char* CMockString_cmock_arg1 = "cmock_arg1";
static const char* CMockString_init_lcd = "init_lcd";
static const char* CMockString_init_spi_bus = "init_spi_bus";
static const char* CMockString_keep_cs_active = "keep_cs_active";
static const char* CMockString_lcd_command = "lcd_command";
static const char* CMockString_lcd_reset = "lcd_reset";
static const char* CMockString_lcd_spi_pre_transfer_callback = "lcd_spi_pre_transfer_callback";
static const char* CMockString_spi = "spi";
static const char* CMockString_start_lcd_controller = "start_lcd_controller";
static const char* CMockString_t = "t";

typedef struct _CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  spi_transaction_t* Expected_t;
  CEXCEPTION_T ExceptionToThrow;
  char ReturnThruPtr_t_Used;
  spi_transaction_t* ReturnThruPtr_t_Val;
  size_t ReturnThruPtr_t_Size;
  char IgnoreArg_t;

} CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE;

typedef struct _CMOCK_init_spi_bus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_init_spi_bus_CALL_INSTANCE;

typedef struct _CMOCK_init_lcd_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  spi_device_handle_t Expected_spi;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_spi;

} CMOCK_init_lcd_CALL_INSTANCE;

typedef struct _CMOCK_start_lcd_controller_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  esp_err_t ReturnVal;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_start_lcd_controller_CALL_INSTANCE;

typedef struct _CMOCK_lcd_reset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int ReturnVal;
  int Expected_cmock_arg1;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_cmock_arg1;

} CMOCK_lcd_reset_CALL_INSTANCE;

typedef struct _CMOCK_lcd_command_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  spi_device_handle_t Expected_spi;
  uint8_t Expected_cmd;
  bool Expected_keep_cs_active;
  CEXCEPTION_T ExceptionToThrow;
  char IgnoreArg_spi;
  char IgnoreArg_cmd;
  char IgnoreArg_keep_cs_active;

} CMOCK_lcd_command_CALL_INSTANCE;

static struct mock_lcd_controllerInstance
{
  char lcd_spi_pre_transfer_callback_IgnoreBool;
  char lcd_spi_pre_transfer_callback_CallbackBool;
  CMOCK_lcd_spi_pre_transfer_callback_CALLBACK lcd_spi_pre_transfer_callback_CallbackFunctionPointer;
  int lcd_spi_pre_transfer_callback_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lcd_spi_pre_transfer_callback_CallInstance;
  char init_spi_bus_IgnoreBool;
  esp_err_t init_spi_bus_FinalReturn;
  char init_spi_bus_CallbackBool;
  CMOCK_init_spi_bus_CALLBACK init_spi_bus_CallbackFunctionPointer;
  int init_spi_bus_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE init_spi_bus_CallInstance;
  char init_lcd_IgnoreBool;
  esp_err_t init_lcd_FinalReturn;
  char init_lcd_CallbackBool;
  CMOCK_init_lcd_CALLBACK init_lcd_CallbackFunctionPointer;
  int init_lcd_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE init_lcd_CallInstance;
  char start_lcd_controller_IgnoreBool;
  esp_err_t start_lcd_controller_FinalReturn;
  char start_lcd_controller_CallbackBool;
  CMOCK_start_lcd_controller_CALLBACK start_lcd_controller_CallbackFunctionPointer;
  int start_lcd_controller_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE start_lcd_controller_CallInstance;
  char lcd_reset_IgnoreBool;
  int lcd_reset_FinalReturn;
  char lcd_reset_CallbackBool;
  CMOCK_lcd_reset_CALLBACK lcd_reset_CallbackFunctionPointer;
  int lcd_reset_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lcd_reset_CallInstance;
  char lcd_command_IgnoreBool;
  char lcd_command_CallbackBool;
  CMOCK_lcd_command_CALLBACK lcd_command_CallbackFunctionPointer;
  int lcd_command_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lcd_command_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void mock_lcd_controller_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.lcd_spi_pre_transfer_callback_CallInstance;
  if (Mock.lcd_spi_pre_transfer_callback_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lcd_spi_pre_transfer_callback);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.lcd_spi_pre_transfer_callback_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.init_spi_bus_CallInstance;
  if (Mock.init_spi_bus_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_init_spi_bus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.init_spi_bus_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.init_lcd_CallInstance;
  if (Mock.init_lcd_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_init_lcd);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.init_lcd_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.start_lcd_controller_CallInstance;
  if (Mock.start_lcd_controller_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_start_lcd_controller);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.start_lcd_controller_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.lcd_reset_CallInstance;
  if (Mock.lcd_reset_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lcd_reset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.lcd_reset_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.lcd_command_CallInstance;
  if (Mock.lcd_command_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lcd_command);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.lcd_command_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_lcd_controller_Init(void)
{
  mock_lcd_controller_Destroy();
}

void mock_lcd_controller_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

void lcd_spi_pre_transfer_callback(spi_transaction_t* t)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lcd_spi_pre_transfer_callback);
  cmock_call_instance = (CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lcd_spi_pre_transfer_callback_CallInstance);
  Mock.lcd_spi_pre_transfer_callback_CallInstance = CMock_Guts_MemNext(Mock.lcd_spi_pre_transfer_callback_CallInstance);
  if (Mock.lcd_spi_pre_transfer_callback_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.lcd_spi_pre_transfer_callback_CallbackBool &&
      Mock.lcd_spi_pre_transfer_callback_CallbackFunctionPointer != NULL)
  {
    Mock.lcd_spi_pre_transfer_callback_CallbackFunctionPointer(t, Mock.lcd_spi_pre_transfer_callback_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_t)
  {
    UNITY_SET_DETAILS(CMockString_lcd_spi_pre_transfer_callback,CMockString_t);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_t), (void*)(t), sizeof(spi_transaction_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.lcd_spi_pre_transfer_callback_CallbackFunctionPointer != NULL)
  {
    Mock.lcd_spi_pre_transfer_callback_CallbackFunctionPointer(t, Mock.lcd_spi_pre_transfer_callback_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  if (cmock_call_instance->ReturnThruPtr_t_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(t, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)t, (void*)cmock_call_instance->ReturnThruPtr_t_Val,
      cmock_call_instance->ReturnThruPtr_t_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lcd_spi_pre_transfer_callback(CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE* cmock_call_instance, spi_transaction_t* t);
void CMockExpectParameters_lcd_spi_pre_transfer_callback(CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE* cmock_call_instance, spi_transaction_t* t)
{
  cmock_call_instance->Expected_t = t;
  cmock_call_instance->IgnoreArg_t = 0;
  cmock_call_instance->ReturnThruPtr_t_Used = 0;
}

void lcd_spi_pre_transfer_callback_CMockIgnore(void)
{
  Mock.lcd_spi_pre_transfer_callback_IgnoreBool = (char)1;
}

void lcd_spi_pre_transfer_callback_CMockStopIgnore(void)
{
  Mock.lcd_spi_pre_transfer_callback_IgnoreBool = (char)0;
}

void lcd_spi_pre_transfer_callback_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE));
  CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_spi_pre_transfer_callback_CallInstance = CMock_Guts_MemChain(Mock.lcd_spi_pre_transfer_callback_CallInstance, cmock_guts_index);
  Mock.lcd_spi_pre_transfer_callback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void lcd_spi_pre_transfer_callback_CMockExpect(UNITY_LINE_TYPE cmock_line, spi_transaction_t* t)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE));
  CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_spi_pre_transfer_callback_CallInstance = CMock_Guts_MemChain(Mock.lcd_spi_pre_transfer_callback_CallInstance, cmock_guts_index);
  Mock.lcd_spi_pre_transfer_callback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_lcd_spi_pre_transfer_callback(cmock_call_instance, t);
}

void lcd_spi_pre_transfer_callback_AddCallback(CMOCK_lcd_spi_pre_transfer_callback_CALLBACK Callback)
{
  Mock.lcd_spi_pre_transfer_callback_IgnoreBool = (char)0;
  Mock.lcd_spi_pre_transfer_callback_CallbackBool = (char)1;
  Mock.lcd_spi_pre_transfer_callback_CallbackFunctionPointer = Callback;
}

void lcd_spi_pre_transfer_callback_Stub(CMOCK_lcd_spi_pre_transfer_callback_CALLBACK Callback)
{
  Mock.lcd_spi_pre_transfer_callback_IgnoreBool = (char)0;
  Mock.lcd_spi_pre_transfer_callback_CallbackBool = (char)0;
  Mock.lcd_spi_pre_transfer_callback_CallbackFunctionPointer = Callback;
}

void lcd_spi_pre_transfer_callback_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_transaction_t* t, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE));
  CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_spi_pre_transfer_callback_CallInstance = CMock_Guts_MemChain(Mock.lcd_spi_pre_transfer_callback_CallInstance, cmock_guts_index);
  Mock.lcd_spi_pre_transfer_callback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_lcd_spi_pre_transfer_callback(cmock_call_instance, t);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void lcd_spi_pre_transfer_callback_CMockReturnMemThruPtr_t(UNITY_LINE_TYPE cmock_line, spi_transaction_t* t, size_t cmock_size)
{
  CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lcd_spi_pre_transfer_callback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_t_Used = 1;
  cmock_call_instance->ReturnThruPtr_t_Val = t;
  cmock_call_instance->ReturnThruPtr_t_Size = cmock_size;
}

void lcd_spi_pre_transfer_callback_CMockIgnoreArg_t(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_spi_pre_transfer_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lcd_spi_pre_transfer_callback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_t = 1;
}

esp_err_t init_spi_bus(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_init_spi_bus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_init_spi_bus);
  cmock_call_instance = (CMOCK_init_spi_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.init_spi_bus_CallInstance);
  Mock.init_spi_bus_CallInstance = CMock_Guts_MemNext(Mock.init_spi_bus_CallInstance);
  if (Mock.init_spi_bus_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.init_spi_bus_FinalReturn;
    memcpy((void*)(&Mock.init_spi_bus_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.init_spi_bus_CallbackBool &&
      Mock.init_spi_bus_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.init_spi_bus_CallbackFunctionPointer(Mock.init_spi_bus_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.init_spi_bus_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.init_spi_bus_CallbackFunctionPointer(Mock.init_spi_bus_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void init_spi_bus_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_init_spi_bus_CALL_INSTANCE));
  CMOCK_init_spi_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_init_spi_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.init_spi_bus_CallInstance = CMock_Guts_MemChain(Mock.init_spi_bus_CallInstance, cmock_guts_index);
  Mock.init_spi_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.init_spi_bus_IgnoreBool = (char)1;
}

void init_spi_bus_CMockStopIgnore(void)
{
  if(Mock.init_spi_bus_IgnoreBool)
    Mock.init_spi_bus_CallInstance = CMock_Guts_MemNext(Mock.init_spi_bus_CallInstance);
  Mock.init_spi_bus_IgnoreBool = (char)0;
}

void init_spi_bus_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_init_spi_bus_CALL_INSTANCE));
  CMOCK_init_spi_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_init_spi_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.init_spi_bus_CallInstance = CMock_Guts_MemChain(Mock.init_spi_bus_CallInstance, cmock_guts_index);
  Mock.init_spi_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void init_spi_bus_AddCallback(CMOCK_init_spi_bus_CALLBACK Callback)
{
  Mock.init_spi_bus_IgnoreBool = (char)0;
  Mock.init_spi_bus_CallbackBool = (char)1;
  Mock.init_spi_bus_CallbackFunctionPointer = Callback;
}

void init_spi_bus_Stub(CMOCK_init_spi_bus_CALLBACK Callback)
{
  Mock.init_spi_bus_IgnoreBool = (char)0;
  Mock.init_spi_bus_CallbackBool = (char)0;
  Mock.init_spi_bus_CallbackFunctionPointer = Callback;
}

void init_spi_bus_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_init_spi_bus_CALL_INSTANCE));
  CMOCK_init_spi_bus_CALL_INSTANCE* cmock_call_instance = (CMOCK_init_spi_bus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.init_spi_bus_CallInstance = CMock_Guts_MemChain(Mock.init_spi_bus_CallInstance, cmock_guts_index);
  Mock.init_spi_bus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

esp_err_t init_lcd(spi_device_handle_t spi)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_init_lcd_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_init_lcd);
  cmock_call_instance = (CMOCK_init_lcd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.init_lcd_CallInstance);
  Mock.init_lcd_CallInstance = CMock_Guts_MemNext(Mock.init_lcd_CallInstance);
  if (Mock.init_lcd_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.init_lcd_FinalReturn;
    memcpy((void*)(&Mock.init_lcd_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.init_lcd_CallbackBool &&
      Mock.init_lcd_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.init_lcd_CallbackFunctionPointer(spi, Mock.init_lcd_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_spi)
  {
    UNITY_SET_DETAILS(CMockString_init_lcd,CMockString_spi);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.init_lcd_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.init_lcd_CallbackFunctionPointer(spi, Mock.init_lcd_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_init_lcd(CMOCK_init_lcd_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t spi);
void CMockExpectParameters_init_lcd(CMOCK_init_lcd_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t spi)
{
  memcpy((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi),
         sizeof(spi_device_handle_t[sizeof(spi) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_spi = 0;
}

void init_lcd_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_init_lcd_CALL_INSTANCE));
  CMOCK_init_lcd_CALL_INSTANCE* cmock_call_instance = (CMOCK_init_lcd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.init_lcd_CallInstance = CMock_Guts_MemChain(Mock.init_lcd_CallInstance, cmock_guts_index);
  Mock.init_lcd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.init_lcd_IgnoreBool = (char)1;
}

void init_lcd_CMockStopIgnore(void)
{
  if(Mock.init_lcd_IgnoreBool)
    Mock.init_lcd_CallInstance = CMock_Guts_MemNext(Mock.init_lcd_CallInstance);
  Mock.init_lcd_IgnoreBool = (char)0;
}

void init_lcd_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_init_lcd_CALL_INSTANCE));
  CMOCK_init_lcd_CALL_INSTANCE* cmock_call_instance = (CMOCK_init_lcd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.init_lcd_CallInstance = CMock_Guts_MemChain(Mock.init_lcd_CallInstance, cmock_guts_index);
  Mock.init_lcd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void init_lcd_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spi_device_handle_t spi, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_init_lcd_CALL_INSTANCE));
  CMOCK_init_lcd_CALL_INSTANCE* cmock_call_instance = (CMOCK_init_lcd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.init_lcd_CallInstance = CMock_Guts_MemChain(Mock.init_lcd_CallInstance, cmock_guts_index);
  Mock.init_lcd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_init_lcd(cmock_call_instance, spi);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void init_lcd_AddCallback(CMOCK_init_lcd_CALLBACK Callback)
{
  Mock.init_lcd_IgnoreBool = (char)0;
  Mock.init_lcd_CallbackBool = (char)1;
  Mock.init_lcd_CallbackFunctionPointer = Callback;
}

void init_lcd_Stub(CMOCK_init_lcd_CALLBACK Callback)
{
  Mock.init_lcd_IgnoreBool = (char)0;
  Mock.init_lcd_CallbackBool = (char)0;
  Mock.init_lcd_CallbackFunctionPointer = Callback;
}

void init_lcd_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t spi, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_init_lcd_CALL_INSTANCE));
  CMOCK_init_lcd_CALL_INSTANCE* cmock_call_instance = (CMOCK_init_lcd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.init_lcd_CallInstance = CMock_Guts_MemChain(Mock.init_lcd_CallInstance, cmock_guts_index);
  Mock.init_lcd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_init_lcd(cmock_call_instance, spi);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void init_lcd_CMockIgnoreArg_spi(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_init_lcd_CALL_INSTANCE* cmock_call_instance = (CMOCK_init_lcd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.init_lcd_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_spi = 1;
}

esp_err_t start_lcd_controller(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_start_lcd_controller_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_start_lcd_controller);
  cmock_call_instance = (CMOCK_start_lcd_controller_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.start_lcd_controller_CallInstance);
  Mock.start_lcd_controller_CallInstance = CMock_Guts_MemNext(Mock.start_lcd_controller_CallInstance);
  if (Mock.start_lcd_controller_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.start_lcd_controller_FinalReturn;
    memcpy((void*)(&Mock.start_lcd_controller_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.start_lcd_controller_CallbackBool &&
      Mock.start_lcd_controller_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.start_lcd_controller_CallbackFunctionPointer(Mock.start_lcd_controller_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.start_lcd_controller_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.start_lcd_controller_CallbackFunctionPointer(Mock.start_lcd_controller_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void start_lcd_controller_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_start_lcd_controller_CALL_INSTANCE));
  CMOCK_start_lcd_controller_CALL_INSTANCE* cmock_call_instance = (CMOCK_start_lcd_controller_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.start_lcd_controller_CallInstance = CMock_Guts_MemChain(Mock.start_lcd_controller_CallInstance, cmock_guts_index);
  Mock.start_lcd_controller_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.start_lcd_controller_IgnoreBool = (char)1;
}

void start_lcd_controller_CMockStopIgnore(void)
{
  if(Mock.start_lcd_controller_IgnoreBool)
    Mock.start_lcd_controller_CallInstance = CMock_Guts_MemNext(Mock.start_lcd_controller_CallInstance);
  Mock.start_lcd_controller_IgnoreBool = (char)0;
}

void start_lcd_controller_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_start_lcd_controller_CALL_INSTANCE));
  CMOCK_start_lcd_controller_CALL_INSTANCE* cmock_call_instance = (CMOCK_start_lcd_controller_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.start_lcd_controller_CallInstance = CMock_Guts_MemChain(Mock.start_lcd_controller_CallInstance, cmock_guts_index);
  Mock.start_lcd_controller_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void start_lcd_controller_AddCallback(CMOCK_start_lcd_controller_CALLBACK Callback)
{
  Mock.start_lcd_controller_IgnoreBool = (char)0;
  Mock.start_lcd_controller_CallbackBool = (char)1;
  Mock.start_lcd_controller_CallbackFunctionPointer = Callback;
}

void start_lcd_controller_Stub(CMOCK_start_lcd_controller_CALLBACK Callback)
{
  Mock.start_lcd_controller_IgnoreBool = (char)0;
  Mock.start_lcd_controller_CallbackBool = (char)0;
  Mock.start_lcd_controller_CallbackFunctionPointer = Callback;
}

void start_lcd_controller_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_start_lcd_controller_CALL_INSTANCE));
  CMOCK_start_lcd_controller_CALL_INSTANCE* cmock_call_instance = (CMOCK_start_lcd_controller_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.start_lcd_controller_CallInstance = CMock_Guts_MemChain(Mock.start_lcd_controller_CallInstance, cmock_guts_index);
  Mock.start_lcd_controller_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

int lcd_reset(int cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lcd_reset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lcd_reset);
  cmock_call_instance = (CMOCK_lcd_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lcd_reset_CallInstance);
  Mock.lcd_reset_CallInstance = CMock_Guts_MemNext(Mock.lcd_reset_CallInstance);
  if (Mock.lcd_reset_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.lcd_reset_FinalReturn;
    Mock.lcd_reset_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.lcd_reset_CallbackBool &&
      Mock.lcd_reset_CallbackFunctionPointer != NULL)
  {
    int cmock_cb_ret = Mock.lcd_reset_CallbackFunctionPointer(cmock_arg1, Mock.lcd_reset_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_cmock_arg1)
  {
    UNITY_SET_DETAILS(CMockString_lcd_reset,CMockString_cmock_arg1);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_cmock_arg1, cmock_arg1, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.lcd_reset_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.lcd_reset_CallbackFunctionPointer(cmock_arg1, Mock.lcd_reset_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lcd_reset(CMOCK_lcd_reset_CALL_INSTANCE* cmock_call_instance, int cmock_arg1);
void CMockExpectParameters_lcd_reset(CMOCK_lcd_reset_CALL_INSTANCE* cmock_call_instance, int cmock_arg1)
{
  cmock_call_instance->Expected_cmock_arg1 = cmock_arg1;
  cmock_call_instance->IgnoreArg_cmock_arg1 = 0;
}

void lcd_reset_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_reset_CALL_INSTANCE));
  CMOCK_lcd_reset_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_reset_CallInstance = CMock_Guts_MemChain(Mock.lcd_reset_CallInstance, cmock_guts_index);
  Mock.lcd_reset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lcd_reset_IgnoreBool = (char)1;
}

void lcd_reset_CMockStopIgnore(void)
{
  if(Mock.lcd_reset_IgnoreBool)
    Mock.lcd_reset_CallInstance = CMock_Guts_MemNext(Mock.lcd_reset_CallInstance);
  Mock.lcd_reset_IgnoreBool = (char)0;
}

void lcd_reset_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_reset_CALL_INSTANCE));
  CMOCK_lcd_reset_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_reset_CallInstance = CMock_Guts_MemChain(Mock.lcd_reset_CallInstance, cmock_guts_index);
  Mock.lcd_reset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void lcd_reset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_arg1, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_reset_CALL_INSTANCE));
  CMOCK_lcd_reset_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_reset_CallInstance = CMock_Guts_MemChain(Mock.lcd_reset_CallInstance, cmock_guts_index);
  Mock.lcd_reset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_lcd_reset(cmock_call_instance, cmock_arg1);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void lcd_reset_AddCallback(CMOCK_lcd_reset_CALLBACK Callback)
{
  Mock.lcd_reset_IgnoreBool = (char)0;
  Mock.lcd_reset_CallbackBool = (char)1;
  Mock.lcd_reset_CallbackFunctionPointer = Callback;
}

void lcd_reset_Stub(CMOCK_lcd_reset_CALLBACK Callback)
{
  Mock.lcd_reset_IgnoreBool = (char)0;
  Mock.lcd_reset_CallbackBool = (char)0;
  Mock.lcd_reset_CallbackFunctionPointer = Callback;
}

void lcd_reset_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, int cmock_arg1, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_reset_CALL_INSTANCE));
  CMOCK_lcd_reset_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_reset_CallInstance = CMock_Guts_MemChain(Mock.lcd_reset_CallInstance, cmock_guts_index);
  Mock.lcd_reset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_lcd_reset(cmock_call_instance, cmock_arg1);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void lcd_reset_CMockIgnoreArg_cmock_arg1(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lcd_reset_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lcd_reset_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_cmock_arg1 = 1;
}

void lcd_command(spi_device_handle_t spi, const uint8_t cmd, bool keep_cs_active)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lcd_command);
  cmock_call_instance = (CMOCK_lcd_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lcd_command_CallInstance);
  Mock.lcd_command_CallInstance = CMock_Guts_MemNext(Mock.lcd_command_CallInstance);
  if (Mock.lcd_command_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.lcd_command_CallbackBool &&
      Mock.lcd_command_CallbackFunctionPointer != NULL)
  {
    Mock.lcd_command_CallbackFunctionPointer(spi, cmd, keep_cs_active, Mock.lcd_command_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_spi)
  {
    UNITY_SET_DETAILS(CMockString_lcd_command,CMockString_spi);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi), sizeof(spi_device_handle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_cmd)
  {
    UNITY_SET_DETAILS(CMockString_lcd_command,CMockString_cmd);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_cmd, cmd, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_keep_cs_active)
  {
    UNITY_SET_DETAILS(CMockString_lcd_command,CMockString_keep_cs_active);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_keep_cs_active, keep_cs_active, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.lcd_command_CallbackFunctionPointer != NULL)
  {
    Mock.lcd_command_CallbackFunctionPointer(spi, cmd, keep_cs_active, Mock.lcd_command_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lcd_command(CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t spi, const uint8_t cmd, bool keep_cs_active);
void CMockExpectParameters_lcd_command(CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance, spi_device_handle_t spi, const uint8_t cmd, bool keep_cs_active)
{
  memcpy((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi),
         sizeof(spi_device_handle_t[sizeof(spi) == sizeof(spi_device_handle_t) ? 1 : -1])); /* add spi_device_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_spi = 0;
  cmock_call_instance->Expected_cmd = cmd;
  cmock_call_instance->IgnoreArg_cmd = 0;
  cmock_call_instance->Expected_keep_cs_active = keep_cs_active;
  cmock_call_instance->IgnoreArg_keep_cs_active = 0;
}

void lcd_command_CMockIgnore(void)
{
  Mock.lcd_command_IgnoreBool = (char)1;
}

void lcd_command_CMockStopIgnore(void)
{
  Mock.lcd_command_IgnoreBool = (char)0;
}

void lcd_command_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_command_CALL_INSTANCE));
  CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_command_CallInstance = CMock_Guts_MemChain(Mock.lcd_command_CallInstance, cmock_guts_index);
  Mock.lcd_command_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void lcd_command_CMockExpect(UNITY_LINE_TYPE cmock_line, spi_device_handle_t spi, const uint8_t cmd, bool keep_cs_active)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_command_CALL_INSTANCE));
  CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_command_CallInstance = CMock_Guts_MemChain(Mock.lcd_command_CallInstance, cmock_guts_index);
  Mock.lcd_command_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_lcd_command(cmock_call_instance, spi, cmd, keep_cs_active);
}

void lcd_command_AddCallback(CMOCK_lcd_command_CALLBACK Callback)
{
  Mock.lcd_command_IgnoreBool = (char)0;
  Mock.lcd_command_CallbackBool = (char)1;
  Mock.lcd_command_CallbackFunctionPointer = Callback;
}

void lcd_command_Stub(CMOCK_lcd_command_CALLBACK Callback)
{
  Mock.lcd_command_IgnoreBool = (char)0;
  Mock.lcd_command_CallbackBool = (char)0;
  Mock.lcd_command_CallbackFunctionPointer = Callback;
}

void lcd_command_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, spi_device_handle_t spi, const uint8_t cmd, bool keep_cs_active, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lcd_command_CALL_INSTANCE));
  CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lcd_command_CallInstance = CMock_Guts_MemChain(Mock.lcd_command_CallInstance, cmock_guts_index);
  Mock.lcd_command_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_lcd_command(cmock_call_instance, spi, cmd, keep_cs_active);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void lcd_command_CMockIgnoreArg_spi(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lcd_command_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_spi = 1;
}

void lcd_command_CMockIgnoreArg_cmd(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lcd_command_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_cmd = 1;
}

void lcd_command_CMockIgnoreArg_keep_cs_active(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lcd_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_lcd_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lcd_command_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_keep_cs_active = 1;
}

